{"version":3,"sources":["angular-aria.js"],"names":["window","angular","undefined","$AriaProvider","watchExpr","attrName","ariaAttr","nodeBlackList","negate","scope","elem","attr","ariaCamelName","$normalize","config","isNodeOneOf","$watch","boolVal","ariaHidden","ariaChecked","ariaDisabled","ariaRequired","ariaInvalid","ariaMultiline","ariaValue","tabindex","bindKeypress","bindRoleForClick","this","newConfig","extend","$get","key","$$watchExpr","ngAriaModule","module","provider","nodeTypeArray","indexOf","nodeName","directive","$aria","shouldAttachAttr","normalizedAttr","shouldAttachRole","role","getShape","type","restrict","require","priority","compile","shape","pre","ngModel","$isEmpty","value","post","ngAriaWatchModelValue","$modelValue","getRadioReaction","needsTabIndex","newVal","$viewValue","ngAriaCheckboxReaction","needsAriaValuemin","hasOwnProperty","needsAriaValuemax","needsAriaValuenow","$observe","$validators","required","$error","$invalid","link","ngMessages","$parse","fn","ngClick","ngKeypress","on","event","callback","$event","keyCode","which","$apply"],"mappings":"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","file":"angular-aria.min.js","sourcesContent":["/**\n * @license AngularJS v1.4.9\n * (c) 2010-2015 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\n/**\n * @ngdoc module\n * @name ngAria\n * @description\n *\n * The `ngAria` module provides support for common\n * [<abbr title=\"Accessible Rich Internet Applications\">ARIA</abbr>](http://www.w3.org/TR/wai-aria/)\n * attributes that convey state or semantic information about the application for users\n * of assistive technologies, such as screen readers.\n *\n * <div doc-module-components=\"ngAria\"></div>\n *\n * ## Usage\n *\n * For ngAria to do its magic, simply include the module `ngAria` as a dependency. The following\n * directives are supported:\n * `ngModel`, `ngDisabled`, `ngShow`, `ngHide`, `ngClick`, `ngDblClick`, and `ngMessages`.\n *\n * Below is a more detailed breakdown of the attributes handled by ngAria:\n *\n * | Directive                                   | Supported Attributes                                                                   |\n * |---------------------------------------------|----------------------------------------------------------------------------------------|\n * | {@link ng.directive:ngDisabled ngDisabled}  | aria-disabled                                                                          |\n * | {@link ng.directive:ngShow ngShow}          | aria-hidden                                                                            |\n * | {@link ng.directive:ngHide ngHide}          | aria-hidden                                                                            |\n * | {@link ng.directive:ngDblclick ngDblclick}  | tabindex                                                                               |\n * | {@link module:ngMessages ngMessages}        | aria-live                                                                              |\n * | {@link ng.directive:ngModel ngModel}        | aria-checked, aria-valuemin, aria-valuemax, aria-valuenow, aria-invalid, aria-required, input roles |\n * | {@link ng.directive:ngClick ngClick}        | tabindex, keypress event, button role                                                               |\n *\n * Find out more information about each directive by reading the\n * {@link guide/accessibility ngAria Developer Guide}.\n *\n * ##Example\n * Using ngDisabled with ngAria:\n * ```html\n * <md-checkbox ng-disabled=\"disabled\">\n * ```\n * Becomes:\n * ```html\n * <md-checkbox ng-disabled=\"disabled\" aria-disabled=\"true\">\n * ```\n *\n * ##Disabling Attributes\n * It's possible to disable individual attributes added by ngAria with the\n * {@link ngAria.$ariaProvider#config config} method. For more details, see the\n * {@link guide/accessibility Developer Guide}.\n */\n /* global -ngAriaModule */\nvar ngAriaModule = angular.module('ngAria', ['ng']).\n                        provider('$aria', $AriaProvider);\n\n/**\n* Internal Utilities\n*/\nvar nodeBlackList = ['BUTTON', 'A', 'INPUT', 'TEXTAREA', 'SELECT', 'DETAILS', 'SUMMARY'];\n\nvar isNodeOneOf = function(elem, nodeTypeArray) {\n  if (nodeTypeArray.indexOf(elem[0].nodeName) !== -1) {\n    return true;\n  }\n};\n/**\n * @ngdoc provider\n * @name $ariaProvider\n *\n * @description\n *\n * Used for configuring the ARIA attributes injected and managed by ngAria.\n *\n * ```js\n * angular.module('myApp', ['ngAria'], function config($ariaProvider) {\n *   $ariaProvider.config({\n *     ariaValue: true,\n *     tabindex: false\n *   });\n * });\n *```\n *\n * ## Dependencies\n * Requires the {@link ngAria} module to be installed.\n *\n */\nfunction $AriaProvider() {\n  var config = {\n    ariaHidden: true,\n    ariaChecked: true,\n    ariaDisabled: true,\n    ariaRequired: true,\n    ariaInvalid: true,\n    ariaMultiline: true,\n    ariaValue: true,\n    tabindex: true,\n    bindKeypress: true,\n    bindRoleForClick: true\n  };\n\n  /**\n   * @ngdoc method\n   * @name $ariaProvider#config\n   *\n   * @param {object} config object to enable/disable specific ARIA attributes\n   *\n   *  - **ariaHidden** – `{boolean}` – Enables/disables aria-hidden tags\n   *  - **ariaChecked** – `{boolean}` – Enables/disables aria-checked tags\n   *  - **ariaDisabled** – `{boolean}` – Enables/disables aria-disabled tags\n   *  - **ariaRequired** – `{boolean}` – Enables/disables aria-required tags\n   *  - **ariaInvalid** – `{boolean}` – Enables/disables aria-invalid tags\n   *  - **ariaMultiline** – `{boolean}` – Enables/disables aria-multiline tags\n   *  - **ariaValue** – `{boolean}` – Enables/disables aria-valuemin, aria-valuemax and aria-valuenow tags\n   *  - **tabindex** – `{boolean}` – Enables/disables tabindex tags\n   *  - **bindKeypress** – `{boolean}` – Enables/disables keypress event binding on `&lt;div&gt;` and\n   *    `&lt;li&gt;` elements with ng-click\n   *  - **bindRoleForClick** – `{boolean}` – Adds role=button to non-interactive elements like `div`\n   *    using ng-click, making them more accessible to users of assistive technologies\n   *\n   * @description\n   * Enables/disables various ARIA attributes\n   */\n  this.config = function(newConfig) {\n    config = angular.extend(config, newConfig);\n  };\n\n  function watchExpr(attrName, ariaAttr, nodeBlackList, negate) {\n    return function(scope, elem, attr) {\n      var ariaCamelName = attr.$normalize(ariaAttr);\n      if (config[ariaCamelName] && !isNodeOneOf(elem, nodeBlackList) && !attr[ariaCamelName]) {\n        scope.$watch(attr[attrName], function(boolVal) {\n          // ensure boolean value\n          boolVal = negate ? !boolVal : !!boolVal;\n          elem.attr(ariaAttr, boolVal);\n        });\n      }\n    };\n  }\n  /**\n   * @ngdoc service\n   * @name $aria\n   *\n   * @description\n   * @priority 200\n   *\n   * The $aria service contains helper methods for applying common\n   * [ARIA](http://www.w3.org/TR/wai-aria/) attributes to HTML directives.\n   *\n   * ngAria injects common accessibility attributes that tell assistive technologies when HTML\n   * elements are enabled, selected, hidden, and more. To see how this is performed with ngAria,\n   * let's review a code snippet from ngAria itself:\n   *\n   *```js\n   * ngAriaModule.directive('ngDisabled', ['$aria', function($aria) {\n   *   return $aria.$$watchExpr('ngDisabled', 'aria-disabled');\n   * }])\n   *```\n   * Shown above, the ngAria module creates a directive with the same signature as the\n   * traditional `ng-disabled` directive. But this ngAria version is dedicated to\n   * solely managing accessibility attributes. The internal `$aria` service is used to watch the\n   * boolean attribute `ngDisabled`. If it has not been explicitly set by the developer,\n   * `aria-disabled` is injected as an attribute with its value synchronized to the value in\n   * `ngDisabled`.\n   *\n   * Because ngAria hooks into the `ng-disabled` directive, developers do not have to do\n   * anything to enable this feature. The `aria-disabled` attribute is automatically managed\n   * simply as a silent side-effect of using `ng-disabled` with the ngAria module.\n   *\n   * The full list of directives that interface with ngAria:\n   * * **ngModel**\n   * * **ngShow**\n   * * **ngHide**\n   * * **ngClick**\n   * * **ngDblclick**\n   * * **ngMessages**\n   * * **ngDisabled**\n   *\n   * Read the {@link guide/accessibility ngAria Developer Guide} for a thorough explanation of each\n   * directive.\n   *\n   *\n   * ## Dependencies\n   * Requires the {@link ngAria} module to be installed.\n   */\n  this.$get = function() {\n    return {\n      config: function(key) {\n        return config[key];\n      },\n      $$watchExpr: watchExpr\n    };\n  };\n}\n\n\nngAriaModule.directive('ngShow', ['$aria', function($aria) {\n  return $aria.$$watchExpr('ngShow', 'aria-hidden', [], true);\n}])\n.directive('ngHide', ['$aria', function($aria) {\n  return $aria.$$watchExpr('ngHide', 'aria-hidden', [], false);\n}])\n.directive('ngModel', ['$aria', function($aria) {\n\n  function shouldAttachAttr(attr, normalizedAttr, elem) {\n    return $aria.config(normalizedAttr) && !elem.attr(attr);\n  }\n\n  function shouldAttachRole(role, elem) {\n    return !elem.attr('role') && (elem.attr('type') === role) && (elem[0].nodeName !== 'INPUT');\n  }\n\n  function getShape(attr, elem) {\n    var type = attr.type,\n        role = attr.role;\n\n    return ((type || role) === 'checkbox' || role === 'menuitemcheckbox') ? 'checkbox' :\n           ((type || role) === 'radio'    || role === 'menuitemradio') ? 'radio' :\n           (type === 'range'              || role === 'progressbar' || role === 'slider') ? 'range' :\n           (type || role) === 'textbox'   || elem[0].nodeName === 'TEXTAREA' ? 'multiline' : '';\n  }\n\n  return {\n    restrict: 'A',\n    require: '?ngModel',\n    priority: 200, //Make sure watches are fired after any other directives that affect the ngModel value\n    compile: function(elem, attr) {\n      var shape = getShape(attr, elem);\n\n      return {\n        pre: function(scope, elem, attr, ngModel) {\n          if (shape === 'checkbox' && attr.type !== 'checkbox') {\n            //Use the input[checkbox] $isEmpty implementation for elements with checkbox roles\n            ngModel.$isEmpty = function(value) {\n              return value === false;\n            };\n          }\n        },\n        post: function(scope, elem, attr, ngModel) {\n          var needsTabIndex = shouldAttachAttr('tabindex', 'tabindex', elem)\n                                && !isNodeOneOf(elem, nodeBlackList);\n\n          function ngAriaWatchModelValue() {\n            return ngModel.$modelValue;\n          }\n\n          function getRadioReaction() {\n            if (needsTabIndex) {\n              needsTabIndex = false;\n              return function ngAriaRadioReaction(newVal) {\n                var boolVal = (attr.value == ngModel.$viewValue);\n                elem.attr('aria-checked', boolVal);\n                elem.attr('tabindex', 0 - !boolVal);\n              };\n            } else {\n              return function ngAriaRadioReaction(newVal) {\n                elem.attr('aria-checked', (attr.value == ngModel.$viewValue));\n              };\n            }\n          }\n\n          function ngAriaCheckboxReaction() {\n            elem.attr('aria-checked', !ngModel.$isEmpty(ngModel.$viewValue));\n          }\n\n          switch (shape) {\n            case 'radio':\n            case 'checkbox':\n              if (shouldAttachRole(shape, elem)) {\n                elem.attr('role', shape);\n              }\n              if (shouldAttachAttr('aria-checked', 'ariaChecked', elem)) {\n                scope.$watch(ngAriaWatchModelValue, shape === 'radio' ?\n                    getRadioReaction() : ngAriaCheckboxReaction);\n              }\n              if (needsTabIndex) {\n                elem.attr('tabindex', 0);\n              }\n              break;\n            case 'range':\n              if (shouldAttachRole(shape, elem)) {\n                elem.attr('role', 'slider');\n              }\n              if ($aria.config('ariaValue')) {\n                var needsAriaValuemin = !elem.attr('aria-valuemin') &&\n                    (attr.hasOwnProperty('min') || attr.hasOwnProperty('ngMin'));\n                var needsAriaValuemax = !elem.attr('aria-valuemax') &&\n                    (attr.hasOwnProperty('max') || attr.hasOwnProperty('ngMax'));\n                var needsAriaValuenow = !elem.attr('aria-valuenow');\n\n                if (needsAriaValuemin) {\n                  attr.$observe('min', function ngAriaValueMinReaction(newVal) {\n                    elem.attr('aria-valuemin', newVal);\n                  });\n                }\n                if (needsAriaValuemax) {\n                  attr.$observe('max', function ngAriaValueMinReaction(newVal) {\n                    elem.attr('aria-valuemax', newVal);\n                  });\n                }\n                if (needsAriaValuenow) {\n                  scope.$watch(ngAriaWatchModelValue, function ngAriaValueNowReaction(newVal) {\n                    elem.attr('aria-valuenow', newVal);\n                  });\n                }\n              }\n              if (needsTabIndex) {\n                elem.attr('tabindex', 0);\n              }\n              break;\n            case 'multiline':\n              if (shouldAttachAttr('aria-multiline', 'ariaMultiline', elem)) {\n                elem.attr('aria-multiline', true);\n              }\n              break;\n          }\n\n          if (ngModel.$validators.required && shouldAttachAttr('aria-required', 'ariaRequired', elem)) {\n            scope.$watch(function ngAriaRequiredWatch() {\n              return ngModel.$error.required;\n            }, function ngAriaRequiredReaction(newVal) {\n              elem.attr('aria-required', !!newVal);\n            });\n          }\n\n          if (shouldAttachAttr('aria-invalid', 'ariaInvalid', elem)) {\n            scope.$watch(function ngAriaInvalidWatch() {\n              return ngModel.$invalid;\n            }, function ngAriaInvalidReaction(newVal) {\n              elem.attr('aria-invalid', !!newVal);\n            });\n          }\n        }\n      };\n    }\n  };\n}])\n.directive('ngDisabled', ['$aria', function($aria) {\n  return $aria.$$watchExpr('ngDisabled', 'aria-disabled', []);\n}])\n.directive('ngMessages', function() {\n  return {\n    restrict: 'A',\n    require: '?ngMessages',\n    link: function(scope, elem, attr, ngMessages) {\n      if (!elem.attr('aria-live')) {\n        elem.attr('aria-live', 'assertive');\n      }\n    }\n  };\n})\n.directive('ngClick',['$aria', '$parse', function($aria, $parse) {\n  return {\n    restrict: 'A',\n    compile: function(elem, attr) {\n      var fn = $parse(attr.ngClick, /* interceptorFn */ null, /* expensiveChecks */ true);\n      return function(scope, elem, attr) {\n\n        if (!isNodeOneOf(elem, nodeBlackList)) {\n\n          if ($aria.config('bindRoleForClick') && !elem.attr('role')) {\n            elem.attr('role', 'button');\n          }\n\n          if ($aria.config('tabindex') && !elem.attr('tabindex')) {\n            elem.attr('tabindex', 0);\n          }\n\n          if ($aria.config('bindKeypress') && !attr.ngKeypress) {\n            elem.on('keypress', function(event) {\n              var keyCode = event.which || event.keyCode;\n              if (keyCode === 32 || keyCode === 13) {\n                scope.$apply(callback);\n              }\n\n              function callback() {\n                fn(scope, { $event: event });\n              }\n            });\n          }\n        }\n      };\n    }\n  };\n}])\n.directive('ngDblclick', ['$aria', function($aria) {\n  return function(scope, elem, attr) {\n    if ($aria.config('tabindex') && !elem.attr('tabindex') && !isNodeOneOf(elem, nodeBlackList)) {\n      elem.attr('tabindex', 0);\n    }\n  };\n}]);\n\n\n})(window, window.angular);\n"],"sourceRoot":"/source/"}